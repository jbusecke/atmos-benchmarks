#!/usr/bin/env bash
#------------------------------------------------------------------------------#
# Isentropic surface interpolation as function of file size
#------------------------------------------------------------------------------#
# Helper function
# We require a subshell to redirect 'time' for some reason; because it's weird
# builtin or something
name=$(echo $0 | tr [A-Z] [a-z])
dir=$1 # directories where data is stored
[ -z "$dir" ] && echo "Error: Please enter location of NetCDFs for globbing/testing." && exit 1
! [ -d "$dir" ] && echo "Error: Directory \"$dir\" not found." && exit 1
output=$dir/${name}_${HOSTNAME%%.*}.log # store here
header="| nlat | size (version) | name | real (s) | user (s) | sys (s) |\n| --- | --- | --- | --- | --- | --- |\n"
echo "Log: $output"
rm $output 2>/dev/null
seconds() {
  # Convert time command output to raw seconds
  m=${1%m*}
  s=${1#*m}
  s=${s%.*}
  t=${1#*.} # tail
  echo "$((m*60 + s)).${t%s}" # converts e.g. 1m35.23s to 85.23s
}
bench() {
  # Run time command
  # NOTE: Must be in a subshell, time is a special bash builtin that doesn't
  # print to 'stdout' *or* 'stderr'
  err=false
  res="$( (time ${@:2}) 2>&1 )"
  [ $? -ne 0 ] && err=true
  echo "$res" | grep "^fatal:" &>/dev/null && err=true
  # $err && echo "Error: Bad exit code." && echo "$res" | sed 's/[[:space:]]*real[[:space:]]*.*//g' && return 1
  $err && echo "$1 Error: Bad exit code." && return 1
  # Optionally print warnings or other messages
  res="$(echo "$res" | grep -v Warning)" # ignore python warnings
  nline=$(wc -l <<< "$res")
  ts=($(tail -n 3 <<< "$res"))
  if [ $nline -gt 4 ]; then # empty line, plus sys, real, user time lines
    other="$(head -n $((nline - 4)) <<< "$res")"
    echo "Lengh of warning messages: $(wc -l <<< "$other")"
  fi
  # echo "Messages:"
  # echo "$other"
  # Get result, tabulate it, add it to markdown file
  real=$(seconds ${ts[1]})
  user=$(seconds ${ts[3]})
  sys=$(seconds ${ts[5]})
  echo "$1 time: ${real}s"
  printf "| $nlat | $size ($version) | $1 | **$real** | $user | $sys |\n" >>$output
}

# Loop over datasets with different resolutions
type gdu &>/dev/null && cmd=gdu || cmd=du # need GNU utils version on mac
datas=($dir/data*.nc)
counter=0
for data in ${datas[@]}; do
  # Header
  # NOTE: The 'disk usage' often very different from the 'apparent size'
  # ls -l; former depends on internals of how data is stored, and on Cheyenne,
  # ends up way bigger. See: https://unix.stackexchange.com/a/106278/112647
  # Explanation of why this happens: https://serverfault.com/a/290091/427991
  size=$($cmd --apparent-size -h $data | xargs | cut -d' ' -f1)
  version=${data%.nc}
  version=${version#*_}
  nlat=${data#*N}
  nlat=$(printf '%.0f' ${nlat%T*})
  echo; echo "Dataset: $data ($size)"
  printf "\n$header" >>$output # add header for each new file
  # sleep 3

  # NCL method
  # NOTE: NCL needs special dyld library path but so does brew, screws
  # up Homebrew if we set it, so set it locally
  export DYLD_LIBRARY_PATH="/usr/local/lib/gcc/4.9"
  bench "NCL" ncl -Q -n "filename=\"$data\"" ${name}.ncl
  export DYLD_LIBRARY_PATH=""

  # Python with MetPy method
  bench "MetPy" python ${name}.py $data 0
done
